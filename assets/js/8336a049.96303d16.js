"use strict";(self.webpackChunkopenmev_docs=self.webpackChunkopenmev_docs||[]).push([[100],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(t),h=r,m=p["".concat(l,".").concat(h)]||p[h]||d[h]||o;return t?a.createElement(m,i(i({ref:n},u),{},{components:t})):a.createElement(m,i({ref:n},u))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=p;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},8378:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=t(3117),r=(t(7294),t(3905));const o={},i=void 0,s={unversionedId:"guides/bundles-adv",id:"guides/bundles-adv",title:"bundles-adv",description:"MEV Bundles",source:"@site/docs/guides/bundles-adv.md",sourceDirName:"guides",slug:"/guides/bundles-adv",permalink:"/guides/bundles-adv",editUrl:"https://github.com/openmev/docs/edit/main/docs/guides/bundles-adv.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"MEV Bundles",permalink:"/guides/creating-bundles"},next:{title:"Flashbots Cheatsheet",permalink:"/guides/cheatsheet"}},l={},c=[{value:"MEV Bundles",id:"mev-bundles",level:2},{value:"Bundle Signing Key",id:"bundle-signing-key",level:2}],u={toc:c};function d(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"mev-bundles"},"MEV Bundles"),(0,r.kt)("p",null,"Searchers that use Flashbots can also use OpenMEV with minimal changes. You can submit bundles to miners (bock\nsynchronizers/producers) for inclusion in blocks."),(0,r.kt)("p",null,"Bundles are one or more transactions that are grouped together and executed in the order they are provided. In addition\nto the searcher's transaction(s) a bundle can also potentially contain other users' pending transactions from the\nmempool, and bundles can target specific blocks for inclusion as well. Here's an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const blockNumber = await provider.getBlockNumber()\nconst minTimestamp = (await provider.getBlock(blockNumber)).timestamp\nconst maxTimestamp = minTimestamp + 120\nconst signedBundle = flashbotsProvider.signBundle(\n    [\n      {\n        signedTransaction: SIGNED_ORACLE_UPDATE_FROM_PENDING_POOL // serialized signed transaction hex\n      },\n      {\n        signer: wallet, // ethers signer\n        transaction: transaction // ethers populated transaction object\n      }\n    ])\nconst bundleReceipt = await flashbotsProvider.sendRawBundle(\n    signedBundle, // bundle we signed above\n    targetBlockNumber, // block number at which this bundle is valid\n    {\n      minTimestamp, // optional minimum timestamp at which this bundle is valid (inclusive)\n      maxTimestamp, // optional maximum timestamp at which this bundle is valid (inclusive)\n      revertingTxHashes: [tx1, tx2] // optional list of transaction hashes allowed to revert. Without specifying here, any revert invalidates the entire bundle.\n    }\n  )\n);\n")),(0,r.kt)("h2",{id:"bundle-signing-key"},"Bundle Signing Key"),(0,r.kt)("p",null,"Typescript function ",(0,r.kt)("inlineCode",{parentName:"p"},"getDefaultRelaySigningKey")," searches for your key, if unable to find a valid key it will generate a\nrandom signing key."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"export function getDefaultRelaySigningKey(): string {\n  console.warn(\n    '[#Error]: BUNDLE_SIGNING_KEY environment variable. Creating random signing key, this searcher will not be building a reputation for next run',\n  );\n  const key = Wallet.createRandom().privateKey;\n  console.log(key);\n  return key;\n}\n")),(0,r.kt)("h1",{id:"coinbasetransfer"},(0,r.kt)("inlineCode",{parentName:"h1"},"coinbase.transfer()")),(0,r.kt)("p",null,"Flashbots allows you to pay miners for your transactions through a smart contract by using\nblock.coinbase.transfer(AMOUNT_TO_TRANSFER). This smart contract function transfers Ethereum from the contract to the\ncoinbase address of the miner who mines that block. Miners running MEV-Geth will treat fees through coinbase transfers\nin the same way they do normal transaction fees, which is to say that 1 wei of coinbase payments is equivalent to 1 wei\npaid through transaction fees. This provides significant benefits to Flashbots users:"),(0,r.kt)("p",null,"You can condition payment to the miner on some criteria being met Related, you can only pay for successful transactions,\nnot failures You can pay for a transaction from account X with ETH from account Y Here's an example from our open source\nsimple arbitrage bot of how paying through coinbase transfers work:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function uniswapWeth(uint256 _wethAmountToFirstMarket, uint256 _ethAmountToCoinbase, address[] memory _targets, bytes[] memory _payloads) external onlyExecutor payable {\n    require (_targets.length == _payloads.length);\n    uint256 _wethBalanceBefore = WETH.balanceOf(address(this));\n    WETH.transfer(_targets[0], _wethAmountToFirstMarket);\n    for (uint256 i = 0; i < _targets.length; i++) {\n        (bool _success, bytes memory _response) = _targets[i].call(_payloads[i]);\n        require(_success); _response;\n    }\n\n    uint256 _wethBalanceAfter = WETH.balanceOf(address(this));\n    require(_wethBalanceAfter > _wethBalanceBefore + _ethAmountToCoinbase);\n    if (_ethAmountToCoinbase == 0) return;\n\n    uint256 _ethBalance = address(this).balance;\n    if (_ethBalance < _ethAmountToCoinbase) {\n        WETH.withdraw(_ethAmountToCoinbase - _ethBalance);\n    }\n    block.coinbase.transfer(_ethAmountToCoinbase);\n}\n\n")),(0,r.kt)("p",null,"The above smart contract code will attempt to capitalize on arbitrage opportunities."),(0,r.kt)("p",null,"If it does not make money doing, so then the transaction will fail. Moreover, since the searcher is paying the miner via\nblock.coinbase.transfer() on the last line then the searcher won't pay any transaction fees."),(0,r.kt)("p",null,"For more information on how coinbase transfers are priced see the bundle pricing page."),(0,r.kt)("p",null,"Managing payments to coinbase. Address when it is a contract# Miners will occasionally have a smart contract listed as\ntheir block.coinbase address. This changes the expected behavior of the making payments to block.coinbase. Specifically\nit costs more gas to transfer ETH to block.coinbase if it is a contract than if it is an EOA, and as such many searchers\nwill underestimate their gas consumption and their bundles will fail for miners who use contracts instead."),(0,r.kt)("p",null,"To handle this edge case searchers can up their gas limit to accommodate the additional payment to miners and call\nblock.coinbase in the following way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"block.coinbase.call{value: _ethAmountToCoinbase}(new bytes(0));\n")),(0,r.kt)("p",null,"However, searchers should be acutely aware of the risk of reentrancy attacks, as calling coinbase in this way\ntemporarily gives execution to a third party, and typically payments to coinbase are made after checks for profit.\nMoreover, searchers should be aware that supporting payments to coinbase addresses that are contracts will cause their\ngas consumption to go up, and as a result their bundle gas price to go down. This is a trade off that should be\nconsidered."))}d.isMDXComponent=!0}}]);